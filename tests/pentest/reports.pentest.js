const puppeteer = require('puppeteer');
const { spawn } = require('child_process');
const request = require('supertest');
const { app } = require('../../src/app');
const { createTestUser, createAuthToken } = require('../helpers');
const config = require('../../src/config');

describe('Reports Penetration Tests', () => {
  let browser;
  let page;
  let testUser;
  let authToken;
  let server;

  beforeAll(async () => {
    testUser = await createTestUser({
      email: 'pentest@example.com',
      password: 'StrongP@ssw0rd123',
      role: 'admin'
    });
    authToken = await createAuthToken(testUser);
    server = app.listen(0);
    
    // Lancer le navigateur pour les tests
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    page = await browser.newPage();
  });

  afterAll(async () => {
    await browser.close();
    await server.close();
  });

  describe('SQL Injection Tests', () => {
    const sqlInjectionPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users; --",
      "' OR '1'='1' /*",
      "admin' --",
      "' OR 1=1; --",
      "') OR ('1'='1",
      "' OR 'x'='x",
      "1; SELECT * FROM users",
      "1' OR '1' = '1')) /*"
    ];

    test.each(sqlInjectionPayloads)('prevents SQL injection: %s', async (payload) => {
      const endpoints = [
        '/api/report-templates',
        '/api/scheduled-reports',
        '/api/users'
      ];

      for (const endpoint of endpoints) {
        const response = await request(app)
          .get(endpoint)
          .set('Authorization', `Bearer ${authToken}`)
          .query({ search: payload });

        expect(response.status).not.toBe(500);
        expect(response.body).not.toContain('sql error');
      }
    });

    it('validates parameterized queries', async () => {
      const response = await request(app)
        .post('/api/report-templates')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: "Test' OR '1'='1",
          type: "works' UNION SELECT * FROM users; --"
        });

      expect(response.status).not.toBe(500);
    });
  });

  describe('Command Injection Tests', () => {
    const commandInjectionPayloads = [
      '& whoami',
      '| cat /etc/passwd',
      '; ls -la',
      '\`id\`',
      '$(touch test.txt)',
      '%0a ping -i 30 127.0.0.1 %0a',
      '| net user',
      '; nc -e /bin/bash',
      '& echo vulnerable &',
      '| dir'
    ];

    test.each(commandInjectionPayloads)('prevents command injection: %s', async (payload) => {
      const response = await request(app)
        .post('/api/report-templates/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: payload,
          format: 'pdf',
          command: payload
        });

      expect(response.status).not.toBe(500);
    });
  });

  describe('Directory Traversal Tests', () => {
    const traversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\win.ini',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '....//....//....//etc/passwd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '/etc/passwd%00.pdf',
      'reports/../../../etc/passwd',
      '.../.../.../etc/passwd',
      '..\\..\\..\\etc\\passwd',
      '....\\\\....\\\\....\\\\etc\\\\passwd'
    ];

    test.each(traversalPayloads)('prevents directory traversal: %s', async (payload) => {
      const response = await request(app)
        .get('/api/report-templates/download')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ path: payload });

      expect(response.status).toBe(400);
    });
  });

  describe('Authentication Bypass Tests', () => {
    const bypassPayloads = [
      { email: 'admin@example.com\' --', password: 'anything' },
      { email: 'admin@example.com" --', password: 'anything' },
      { email: 'admin@example.com\' OR \'1\'=\'1', password: 'anything' },
      { email: 'admin@example.com" OR "1"="1', password: 'anything' },
      { email: 'admin@example.com\' OR 1=1 --', password: 'anything' },
      { email: 'admin@example.com" OR 1=1 --', password: 'anything' }
    ];

    test.each(bypassPayloads)('prevents authentication bypass: %j', async (payload) => {
      const response = await request(app)
        .post('/api/auth/login')
        .send(payload);

      expect(response.status).toBe(401);
    });
  });

  describe('Session Hijacking Tests', () => {
    it('prevents session fixation', async () => {
      const initialResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'pentest@example.com',
          password: 'StrongP@ssw0rd123'
        });

      const initialSessionId = initialResponse.headers['set-cookie'][0];

      const loginResponse = await request(app)
        .post('/api/auth/login')
        .set('Cookie', initialSessionId)
        .send({
          email: 'pentest@example.com',
          password: 'StrongP@ssw0rd123'
        });

      const newSessionId = loginResponse.headers['set-cookie'][0];
      expect(newSessionId).not.toBe(initialSessionId);
    });

    it('validates session tokens', async () => {
      const response = await request(app)
        .get('/api/report-templates')
        .set('Cookie', 'session=invalid-session-id');

      expect(response.status).toBe(401);
    });
  });

  describe('File Upload Tests', () => {
    const maliciousFiles = [
      { name: 'test.php', content: '<?php system($_GET["cmd"]); ?>' },
      { name: 'test.jsp', content: '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>' },
      { name: 'test.asp', content: '<% eval request("cmd") %>' },
      { name: 'test.js', content: 'process.exit(1);' },
      { name: 'test.html', content: '<script>alert(1)</script>' }
    ];

    test.each(maliciousFiles)('prevents malicious file upload: $name', async ({ name, content }) => {
      const response = await request(app)
        .post('/api/report-templates/import')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', Buffer.from(content), name);

      expect(response.status).toBe(400);
    });

    it('validates file content type', async () => {
      const response = await request(app)
        .post('/api/report-templates/import')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', Buffer.from('fake pdf content'), {
          filename: 'malicious.pdf',
          contentType: 'application/x-httpd-php'
        });

      expect(response.status).toBe(400);
    });
  });

  describe('DoS Protection Tests', () => {
    it('handles large payload attacks', async () => {
      const largePayload = 'A'.repeat(10 * 1024 * 1024); // 10MB

      const response = await request(app)
        .post('/api/report-templates')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: largePayload,
          type: 'works'
        });

      expect(response.status).toBe(413);
    });

    it('limits concurrent connections', async () => {
      const concurrentRequests = Array(1000).fill().map(() =>
        request(app)
          .get('/api/report-templates')
          .set('Authorization', `Bearer ${authToken}`)
      );

      const responses = await Promise.all(concurrentRequests);
      const tooManyRequests = responses.filter(r => r.status === 429);

      expect(tooManyRequests.length).toBeGreaterThan(0);
    });
  });

  describe('Browser Security Tests', () => {
    it('prevents clickjacking', async () => {
      await page.goto(`http://localhost:${server.address().port}`);
      const frame = await page.$('iframe');
      expect(frame).toBeNull();
    });

    it('enforces secure headers', async () => {
      const response = await request(app)
        .get('/api/report-templates')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.headers).toMatchObject({
        'x-frame-options': 'DENY',
        'x-content-type-options': 'nosniff',
        'x-xss-protection': '1; mode=block',
        'strict-transport-security': expect.stringContaining('max-age='),
        'referrer-policy': 'strict-origin-when-cross-origin'
      });
    });
  });

  describe('API Security Tests', () => {
    it('validates request body size', async () => {
      const response = await request(app)
        .post('/api/report-templates')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'A'.repeat(1000000),
          type: 'works'
        });

      expect(response.status).toBe(413);
    });

    it('prevents parameter pollution', async () => {
      const response = await request(app)
        .get('/api/report-templates')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ sort: ['asc', 'desc'] });

      expect(response.status).toBe(400);
    });
  });
});
